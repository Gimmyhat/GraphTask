# GraphTask

## Тестовое задание по графовым базам данных

1. Установить 2 графовые базы из списка [DB-Engines Ranking](https://db-engines.com/en/ranking/graph+dbms) \
  a. Предпочтительные - neo4j, nebula, arangodb \
  b. Предпочтительный язык запросов cypher
2. Создать ipynb ноутбук в котором:
3. Считать данные из источника [GraphTask](https://disk.yandex.ru/d/s6wWqd8Ol_5IvQ)
4. Внести данные из таблицы в графовую БД
5. Построить графовое представление в БД, осуществить несколько запросов на языке запросов к графовой БД
6. Найти взаимосвязи визуально и с помощью алгоритмов (алгоритмы на ваше усмотрение)
7. Написать rest сервис на python к графовой БД в котором на вход поступает ФИО, на выходе graphml или json
8. Результаты представить на гитхаб и в виде кода + небольшой презентации

____

## Установка и запуск Neo4j
Для установки и запуска Neo4j я использую Docker. Установите Docker на свой компьютер и выполните следующие команды:
```
docker run \
    --publish=7474:7474 --publish=7687:7687 \
    --volume=$HOME/neo4j/data:/data \
    --env NEO4J_AUTH=none \
    neo4j:latest
```
После того, как контейнер будет запущен, вы сможете получить доступ к интерфейсу пользователя Neo4j через веб-браузер, открыв http://localhost:7474.

### Шаг 1. Считывание данных из источника

Для чтения данных из файла можно использовать библиотеку Pandas

### Шаг 2. Внесение данных в графовую БД

Для внесения данных в графовую БД можно использовать библиотеку Py2neo

### Шаг 3. Построение графового представления в БД

Для построения графового представления можно использовать язык запросов Cypher:

```
# Выполняем запрос на получение всех участников и событий
query = """
MATCH (p:Person)-[:PARTICIPATED_IN]->(e:Event)
RETURN p.name, e.id
"""

# Выполняем запрос и выводим результаты
result = graph.run(query)
for row in result:
    print(row)

```
### Шаг 4. Поиск взаимосвязей

Для выявления взаимосвязей в графе можно применить алгоритмы кластеризации и поиска центральности.

Алгоритм кластеризации помогает разбить граф на группы узлов с более высокой степенью взаимосвязей 
внутри группы, чем между группами. Одним из наиболее популярных алгоритмов кластеризации является 
алгоритм Лувена (Louvain algorithm).

Алгоритм поиска центральности позволяет определить узлы в графе, которые играют наиболее важную роль 
в связях между другими узлами. Существует несколько алгоритмов поиска центральности, таких как 
центральность по посредничеству (betweenness centrality), центральность по близости (closeness centrality) 
и центральность по степени (degree centrality).

### Шаг 5. Написание REST сервиса

Для создания REST-сервиса на Python к графовой БД, в котором на вход поступает ФИО, а на выходе получаем graphml или json, можно использовать Flask.

В данном примере при запросе GET /person/<name> в URL указывается имя персоны, для которой необходимо получить информацию о связях. 
В ответ сервис возвращает JSON с именем персоны и списком связей, где каждая связь представляет собой тип связи и имя узла, с которым 
связана персона. Если персона с указанным именем не найдена, сервис возвращает ошибку 404.

```
from flask import Flask, jsonify
from py2neo import Graph

app = Flask(__name__)

app.config['JSON_AS_ASCII'] = False

graph = Graph("bolt://localhost:7687", auth=("neo4j", "0123456789"))


@app.route('/person/<name>', methods=['GET'])
def get_person(name):
    query = (
        "MATCH (p:Person {name: $name})-[:PARTICIPATED_IN]->(b:Person)"
        "RETURN p.name AS person, COLLECT(b.name) AS related_people"
    )
    results = graph.run(query, name=name).data()

    if not results:
        return jsonify({'error': 'Person not found'}), 404

    return jsonify(results[0])


if __name__ == '__main__':
    app.run(debug=True)
```
